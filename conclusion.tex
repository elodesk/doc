\chapter{Conclusion}
\section{Results}
\subsection{Prestudy}
The first result of this thesis is the prestudy documentation, which
resumes gathered knowledge in the familiarization phase of this work.
It gives an insight in messaging fundamentals and  takes a closer look to Apache
Kafka and related topics.

\subsection{Protocol Implementation}
A fundamental result of this thesis is the implementation of the Apache Kafka
protocol in Haskell. The design decision of separating protocol related code
from the broker implementation leads to a isolated product which can be used as
library for different project. The code is provided through an open sourced
repository for further development. \todo{ref to Github}

A complete implementation of the Apache Kafka Protocol would go beyond the scope
of this thesis as the focus lies not only in implementing the protocol but also
to provide broker functionality (see Chapter \ref{chap:broker}). Thus, most
important is the ability to produce and fetch messages. The following list gives
an overview of what part of the protocol is implemented and what remains open:

\begin{itemize}
    \item Metadata API
    \begin{itemize}
        \tick Topic Metadata Request
        \tick Metadata Response
    \end{itemize}
    \item Produce API
    \begin{itemize}
        \tick Produce Request
        \tick Produce Response
    \end{itemize}
    \item Fetch API
    \begin{itemize}
        \tick Fetch Request
        \tick Fetch Response
    \end{itemize}
    \item Offset API
    \begin{itemize}
        \fail Offset Request
        \fail Offset Response
    \end{itemize}

    \item Offset Commit/Fetch API
    \begin{itemize}
        \fail Consumer Metadata Request
        \fail Consumer Metadata Response
        \fail Offset Commit Request
        \fail Offset Commit Response
        \fail Offset Fetch Request
        \fail Offset Fetch Response
    \end{itemize}
\end{itemize}

\subsection{Haskell Message Broker}
The main approach of this work is the implementation of a message broker in
Haskell. The resulting application provides a server with basic functionality
in networking and persisting messages. The broker supports Kafka clients as
it is based on the protocol implementation mentioned above.

..?: 

Producing Messages: 
\begin{itemize}
        \tick Publishing messages to specific topic and partition
        \tick Persist messages in log based file structure
        \tick Support batched messages 
        \tick Support producing for multiple topics and partitions
        \fail Configurable Acknowledgements and Timeout
\end{itemize}

Fetch Messages: 
\begin{itemize}
        \tick Consuming messages of a specific topic and partition
        \tick Request Messages depending on given offset
        \fail Support consuming from multiple topics and partitions 
        \fail Support configurable min and max bytes for fetched data
        \fail Support maximum amount of time to block, waiting if insufficient
        data is available
\end{itemize}
Clustering: The scope lies on a single broker system with a producer and
consumer API. There is no support for broker replication yet. 

\section{Evaluation}
After highlighting the implemented features above, the question about
performance appears. Is the provided prototype already faster than the original
Apache Kafka or has it near the same throughput? Or are we still fare away from any
approximation to the impressive performance of the reference system? This
chapter will show the results of some benchmark tests.

-> Test System

Broker Server Setup
\begin{verbatim}
Intel(R) Xeon(R) CPU E3-1245 v3 @ 3.40GHz
One 7200 RPM SATA drive
16GB of RAM
1Gb Ethernet 
\end{verbatim}

\subsection{Network Throughput}
The socket based communication must not be a bottleneck in a high performance
broker. A producer should be able to send with near the maximal throughput of
its local network card, whereas the broker needs to handle the incoming data
streams as fast as possible. If the limits of a single network connection is
reached, the next step to improve performance is to balance the data
stream on multiple replicated brokers.

To test the network throughput for this thesis, a benchmark producer
which identify the limits is provided.

\begin{lstlisting}
import qualified System.Entropy as E

main = do 
    -- Socket setup 
    -- ....

    randBytes <- E.getEntropy 1000
    let
\end{lstlisting}


The variance seems to be due to Linux's I/O management facilities that batch
data and then flush it periodically.
-> DurchgefÃ¼hrte Tests 

-> Resultat Network Throuput 

-> Resultat Writing to the log 
-> Vergleich Kafka (ref to Blog) 

\begin{table}[h]
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Request Size (with ReqHeader)} & {\bf Message Size {[}Byte{]}} & {\bf Batch Size} & {\bf \begin{tabular}[c]{@{}c@{}}Avg. Throughput\\ {[}MB/s{]}\end{tabular}} \\ \hline
150 B                               & 100                           & 1                & 27                                                                         \\ \hline
1050 B                              & 100                           & 10               & 22                                                                         \\ \hline
10.050 KB                           & 100                           & 100              & 30                                                                         \\ \hline
100.050 KB                          & 100                           & 1000             & 32                                                                         \\ \hline
1 MB                                & 100                           & 10000            & 40                                                                         \\ \hline
550 B                               & 500                           & 1                & 66                                                                         \\ \hline
1050 B                              & 500                           & 2                & 81                                                                         \\ \hline
10.050 B                            & 500                           & 20               & 80                                                                         \\ \hline
100.050 KB                          & 500                           & 200              & 96                                                                         \\ \hline
1 MB                                & 500                           & 2000             & 68                                                                         \\ \hline
1050 B                              & 1000                          & 1                & 104                                                                        \\ \hline
10.050 B                            & 1000                          & 10               & 110                                                                        \\ \hline
100.050 KB                          & 1000                          & 100              & 112                                                                        \\ \hline
1 MB                                & 1000                          & 1000             & 87                                                                         \\ \hline
10.050 B                            & 10000                         & 1                & 117                                                                        \\ \hline
100.050 KB                          & 10000                         & 10               & *                                                                          \\ \hline
1 MB                                & 10000                         & 100              & *                                                                          \\ \hline
\end{tabular}
\end{table}


\section{Outlook}
-> What are the next step? 

- Further optimizations 
- Implementation and handling of remaining API's 
- Replication and Integration With Apache Zookeeper 
- Ausbauen von Client API 
-> Open Source 

-> 
- broker results promissing
- very extendable/scalable implementation base and architecture
- with further work one could build the current prototype to an extraordinary
broker system.

As for now, the highlight remains the protocol implementation which has already
been praised by the Haskell community and found its contributors they helped
uncovering minor issues.

