\chapter{Introduction to Messaging} 

\section{Message Oriented Middleware}
\label{intro-messaging-mom}
Introducing an intermediate component between distributed
clients, messaging reduces the close coupling of other communication styles just
based on \gls{Socket}s or RMI. This additional component can be named as
Message-Oriented Middleware (MOM) and is all about passing messages in any
format from one application to another whereas the parties do not need to know
each other directly. Thereby the main characteristic of a MOM is that its
supports a storage capacity which leads to a persistent way of communication where it is
not required that the collaborating endpoints are active during the entire
transmission of a message. This loose coupling in time is achieved by
working with queues as data structure (first-in-first-out) where applications
can insert their messages and a receiver program can read from this queue at a
different time. In normal case the original sender
never has the guarantee that the sent message has arrived at the desired
destination but it always has the confirmation of the MOM that the data has put
in a message queue. \cite{PprIBMIntro} \cite{TAN06}

\todo[inline]{TODO: Definition Message (data type)}
\todo[inline]{TODO: Einleitung, unterscheidung verschiedenen kommunikations
möglichkeiten, Point-to-Point vs Broker}

\section{Interoperablity}
Because its interoperability, messaging is a very interesting communication
style for enterprise integration. Basically interoperability means that system with
different technologies can collaborate together by using the same standard or
protocols. While using a messaging system in an enterprise environment it is
much more efficient to integrate a new application to the existing data flow.
Instead of implementing a new interface for another technology, the additional
software can be just linked to the existing MOM by using the underlying
messaging protocol.\\

In the past, several companies like IBM or Microsoft developed their own
proprietary standards and protocols for asynchronous messaging systems.
Probably to keep it locked in their customer base. In June 2001 the Java Message
Service API (JMS) was released as best-known standard for messaging systems.
However, it is only an interface an not a specific protocol, JMS implementations
need to define their own. There was still no general protocol standard which
would have allowed to interoperate between different messaging implementations.
Fortunately in June 2006 a pool of multiple companies for network technologies
defined the Advanced Message Queueing Protocol (AMQP) as a open standard for an
interoperable messaging protocol. \cite{PrpAMQP}
 
%\begin{description} 
%	\item [Advanced Message Queuing Protocol (AMQP)] \hfill
%    \item [JMS]	
%\end{description}

\section{Point-To-Point Connection}
A Point-To-Point connection is the simplest architecture for communicating in a
messaging system. In a very basic scenario with a node A as sender of a message
and a node B as receiver, the MOM (running either on the node itself or
dedicated in the local network) assumes the task of handling a local queue for messages and manages an address-lookup
database for mapping destination names to network locations. The sender puts its
message in his local queue whereas the MOM organises the network transfer to the
queue of the target. In turn the receiver system can read from its own
local queue the incoming message. The MOM provides a specific API for both the
sender as well for the receiver:
\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Put}    & Append a message to a specific queue                                        \\ \hline
\textbf{Get}    & Block until the specific queue is nonempty, and remove the first message    \\ \hline
\textbf{Poll}   & Check a specific queue for messages, and remove the first                   \\ \hline
\textbf{Notify} & Install a handler to be called when a message is put into a specified queue \\ \hline
\end{tabular}
\caption[TAN06]{Basic API for message queue implementation \cite{TAN06}}
\end{table}

This kind of communcation works well in an environment with two systems which
want to collaborate and use the advantages of messaging. But if there are more
than two nodes, the local mapping of a queue name to a foreign network location
implies that each system needs to hold the addresses of all the other nodes that it
wants to communicate with. When a target address changes, all the systems that
communicate with the target must be updated. In most scenarios there is also a need
for transforming messages in different format where these implementations have
to be made on every node, which leads to duplicating code.  For more complex
integration solutions, a centralised solution whereas the MOM runs on a location
independent platform is required. This is where the message broker comes into
game. \cite{MSDNIntegration}

\section{Message Broker}
A messaging system with point-to-point connections can decouple two systems
by using a managed queue on each side of a collaboration. But there is
still the need of configuration the endpoints on each party. In general, a
message broker is a dedicated component which decouples source and
target systems by assuming full responsibility for coordinating communication between
all connected nodes. Thereby the main tasks of a message broker are the
dynamically registration of endpoints, determining location of target system
(a.k.a. routing) and performing of the communication as well transformation of a
message from one format to another.\cite{MSDNIntegration} \\

\subsection{Broker Pattern}
As initial point for the detailed definition of a message broker we take the
\textit{Broker Pattern} of  \textit{Patterns of Software Architecture Volume1}
which can be used to structure distributed systems with decoupled components.
Basically it differs between two types of brokers, where the \textit{Direct
Broker} performs a initialization of a connection but the following communication
is only between the two endpoints. For messaging, the second variant
\textit{Indirect Broker}, is lot more interesting because it maintains all of
the communication between the nodes at every time. So let us define the message
broker as refinement of the Indirect Broker Pattern for message-based
communication.\cite{POSA1} 

\subsection{Structure}

\subsection{Endpoint registration}
 
\todo[inline]{TODO: Broker Pattern (POSA1) -> Indirect Broker -> Message Broker}

TODO: Sequenzdiagram ausarbeiten
\begin{figure}[H]
    \centering
     \begin{sequencediagram}
        %\newthread{broker}{Broker}
        \newinst[1]{producer}{Producer}
        \newinst[2]{producerProx}{Producer Proxy}
        \newinst[3]{broker}{Broker}
        \newinst[4]{consumerProx}{Consumer Proxy}
        \newinst[5]{consumer}{Consumer}
        \begin{call}
            {producer}{(1) Send Request}{producerProx}{}
        \end{call}
        \begin{call}
            {producerProx}{(3) Forward data}{broker}{}
        \end{call}
    \end{sequencediagram}
    \caption{Producer sends message ...}
    \label{fig:MB-SSD-1}
\end{figure}
%We saw that a \textit{Broker} acts like a mediator between to collaborating
%applications which do not need to know each other. The same does a message
%broker, of course in a message-oriented distributed system whereas the broker
%handles incoming messages from a source to a target and backwards.

In such an environment it is essential that existing and new applications can be
integrated into a single, coharent system at runtime. Often these applications
are not speaking the same language and it need kind of a gateway for
transforming messages into a format that can be unterstood by the receiver.
\cite{TAN06}

\subsection{Routing and Communicating}

\subsection{Transformation}

\subsection{Further terminology}

\subsubsection{Channels and Topics} %todo: probably split in two sections
Channel unterscheided zwischen Producer and Consumer. Wurde eine Nachricht
Topic unterscheided zwischen Publisher und Subscriber
konsumiert, wird sie aus der Queue gelöscht.

\subsubsection{Publish / Subscribe}
Sending messages to the broker in form of publishing to a specific topic and on
the other hand receiving messages only for the specified topic, is called
publish/subscribe. In contrast to a one-to-one channel, the message broker
requires the abilities to match messages on an application based level to act as
a gateway for topic related messages. Based on the informations provided within
the messages, the broker is being able to provide the messages to the client
acting as a subscriber \cite{TAN06}. In fact, the publish/subscribe channel
delivers a copy of the topic related messages to the output channel. This also
means that there can be more than one channel that consumes the topic specific
messages and thus there can be more than one subscriber. \cite{EIP03}

\subsubsection{Pull / Push}

